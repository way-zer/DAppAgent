const {Project, ModuleDeclarationKind, TypeFormatFlags, Type, Writers} = require('ts-morph');
const path = require('path');

const mainDir = path.resolve(__dirname, '..');
const project = new Project({
    tsConfigFilePath: path.join(mainDir, 'tsconfig.json'),
});

const dtsFile = project.createSourceFile('../sdk/services.d.ts', undefined, {overwrite: true});
dtsFile.addStatements('//Auto generated by genType.js');


const dir = project.getDirectory(path.join(mainDir, 'src', 'apis', 'services'));
const solvedImport = [];

function transformDynamicImport(text) {
    return text.toString().replaceAll(/import\("([^"]+)"\)\.(\w+)/g, (_, module, name) => {
            function resolveImport() {
                console.log('import', module + '@' + name);
                const source = project.getSourceFile(module + '.ts') || project.getSourceFile(module + '.d.ts') || project.getAmbientModule(module);
                {
                    const sType = source.getInterface(name);
                    if (sType) {
                        const structure = sType.getStructure();
                        for (const p of structure.properties) {
                            p.type = transformType(sType.getPropertyOrThrow(p.name).getType());
                        }
                        // debugger
                        dtsFile.addInterface({
                            ...structure, isExported: false,
                        });
                        return;
                    }
                }
                {
                    const sType = source.getTypeAlias(name);
                    if (sType) {
                        let {name, type} = sType.getStructure();
                        const rawType = sType.getType();
                        if (rawType.isIntersection()) {
                            type = Writers.intersectionType(
                                ...rawType.getIntersectionTypes().map(it => transformType(it)),
                            );
                        } else if (rawType.isUnion()) {
                            type = Writers.unionType(
                                ...rawType.getUnionTypes().map(it => transformType(it)),
                            );
                        } else if (rawType.isObject()) {
                        }
                        dtsFile.addTypeAlias({name, type});
                        return;
                    }
                }
                {
                    console.warn('Not resolve dynamic import', module, name);
                    dtsFile.addTypeAlias({name: name, docs: ['Not resolve'], type: '{}'});
                }
            }

            if (!solvedImport.includes(module + '@' + name)) {
                solvedImport.push(module + '@' + name);
                resolveImport();
            }
            return name;
        },
    );
}

function transformType(type) {
    const text = type.getText(dtsFile);
    console.log('transform', text);
    if (text === 'AppInfo') debugger
    return transformDynamicImport(text);
}

// Service Classes
for (const file of dir.getSourceFiles()) {
    for (const cls of file.getClasses()) {
        if (cls.getExtends()?.getText() !== 'ExposedService') continue;
        const structure = cls.extractInterface();
        structure.properties = [];
        for (const method of structure.methods) {
            const raw = cls.getMethodOrThrow(method.name);
            if (!raw.getDecorator('api')) {
                structure.methods.splice(structure.methods.indexOf(method), 1);
                continue;
            }
            const apiTag = {tagName: 'api', text: raw.getDecorator('api').getText().replace('@api', '')};
            if (method.docs.length) method.docs[0].tags.push(apiTag);
            else method.docs.push({tags: [apiTag]});
            method.returnType = transformType(raw.getReturnType());
        }
        dtsFile.addInterface(structure);
    }
}

//define
const file = dir.getSourceFile('index.ts');
const services = file.getTypeAliasOrThrow('Services');
dtsFile.addTypeAlias({name: 'Services', isExported: true, type: services.getType().getText(services)});
dtsFile.saveSync();
